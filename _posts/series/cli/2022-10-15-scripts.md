---
layout: post
title:  "Automating Tasks with Bash"
date: 2022-10-03
author: Deshawn Sambrano
tags: Coding Unix Bash Shell
time: 10
draft: true
usemathjax: true
category: cli
series: cli
diff: intermediate

---

{% include sidebar.html %}

<section class="takeaways">

This is a intermediate-level follow up to the cli. Specifically you will learn:
- How to make a bash script (Setting a language with Shebang `#!`; Changing permissions `chmod`)
- Taking in arguments/user input for your script
- Change your `$PATH` to run scripts anywhere
- What is `.bashrc` / `.zshrc`

Prerequisites:

- Knowledge of basic shell commands
- Read through the [Command line (Bash/Zsh)](cli.md)

</section>

## What are Scripts?

<!-- excerpt-start -->
A script is just a combination of commands put into a file so that you can run all of those commands at once.
Scripts also allow you to read in arguments and even read in user inputs in the middle of the script.

To start off you need to create a file, feel free to use any of the command line text editors, or your favorite IDE (some examples include: Visual Studio Code, Sublime Text, etc.), you typically want to avoid things like Notepad and TextEdit as they both can sometime add extra unwanted characters that can mess up scripts.
You can name it anything, but make sure it has the `.sh` extension (not requried, but helpful for beginners to know what files are shell scripts).
I will be naming is `my_first_script.sh`.

<!-- excerpt-end -->

## Shebang `#!`

Once you open your file, on the first line you need to add a shebang `#!`.
Shebangs are use to indicate which interpreter the script should use.
In other words, which language should be used.
In the vast majority of cases you should use:

```shell
#!/usr/bin/env LANGUAGE
```

where language is replaced with the relevant language like `bash` `zsh` or `python` etc.
To make sure the script does something, we are going to use the `echo` function.
This will print text to the console.
In our case we will add `echo "Hello from my first script"` to the file.
So the full file should look like this:

```bash
#!/usr/bin/env bash

echo "Hello from first script"
```

Running the file should print "Hello from my first script" to the console.
But how do you run a script.

## Running Scripts

Now that we have our script ready its time to run it.
To do so we need to make sure it has the proper permissions.
Lets check the permissions with `ls -lh`:

![](/assets/imgs/rwx.png)

Focus on the text on the left, specifically the `rw-r--r--`.
This is telling you about the permissions for the file you are reading.
They are repeated three times, the first set is for the owner of the file (since you made the file that's you), the second is for the user's group (beyond the scope of this post), and the final section is for any user on the computer.

They stand for read `r`, write `w`, and execute `x` permissions.
As you might have guessed, the read permissions means those users can read the file, while write permissions means they can edit the file.
Execute permissions means you can run it as a script.
Notice currently, we do not have `x` permissions, so we need to give the file the permission to be run before it will work.
For more information on permissions, you can check out this [post][permissions].

We can do this with the `chomod` command.
The `chomod` command changes the file's permission based on the options you select.
You can either use `chomod 755 file_name` or `chomod +x file_name`.
The first one specifically assigns read, write and execute permissions for the owner; and assigns read and execute for all other users.
The second one, specifically, just adds execution permissions to all users.
When you run this command, you probably will see and error.

![chomod error](/assets/imgs/chmod-error.png)

This is because you need permission to change the files execution status.
This is just like how you are asked to type in your admin password when installing a new application.
To do that on the command-line, you need the `sudo` command.

### Super User (sudo)

`sudo` stands for **S**uper **U**ser **DO**.
The super user is a special all-powerful user on your computer.
Anything the superuser says to happen will happen (so be careful when allowing apps to have super user previledges).

When you run a command with `sudo` escalation/priveledges you will also need to type in your password.
If you setup your computer to have admin rights, then you will also be able to use `sudo`.
On the other hand if you don't have admin rights / your company or university set up your computer, you might need to ask them to give you `sudo` priveledges (but its worth trying this command first, because they might have given you priveledges anyways).

When you type in your password in the command-line you should know that it will not show you typing anything.
This is normal and is designed to improve security, but it can be confusing for first time users.
So just type your password as normal.
If you make a mistake, you can always press backspace a bunch of times and type again.

Now you can combo the `sudo` command with the `chomod` command.

![Sudo chmod](/assets/imgs/sudo-chmod.png)

As you can see, now we finally have execute permission on this file.


> One neat trick, is you can actually type `sudo !!` to say rerun the previously typed command but now with sudo priveledges.

In order to actually run the file.
All we need to do is type `./file_name`.
The `.` means specifically check the current folder because that is not the default place your computer will look for commands (more on that in this [post][path]).
And since we included the shebang it will run the script in the write language.
Here is what is looks like:

![My First Script](/assets/imgs/first-script.png)

Now that we got that whole process working, we can run the script anytime as long as we are in the correct working directory or specify how to get there.
Luckily, we only have to do that process once, now that is has th proper permissions, it will stay that way!
Now we can get to adding more functionality to our script with argumnets.

## What is a Variable?

A variable is a part of your script that can change either from user input or come other parts of your script.
Variables are a foundational part of any programmers toolkit because they allow you to write code that is adaptable to the use case instead of having to know all of the details before the project starts.
<!--
Here, I am just going to spell out some good practices with variables.
For example, typically you want to always create/assign all your variables at the top of your script.
There are some exceptions, but in general, you should try to stick to this rule.
It helps make your code much more readable and editable in the future so its good to get in the habit early.
Another type is if you assign it once, and dont expect it to ever change, then you typically use all caps (using underscores instead of dashes).
In contrast, if its a variable that you expect to change a few times or only lives inside a fucntion, then it can be lower case.
This is not set in stone, but again its a good practice to have in all languages.
For more best tips on general good practices I will be making one in the future, but until then you can check out [Googles Shell Style Guide][google-bash-style].
-->
When defining a variable in your script, you will need to know a few things.
To define a variable you need to use the following structure:

```bash
VARIABLE_NAME=VALUE
```

Importantly, there should be no spaces before and after the `=`.
Once you have a variable stored, you can use it anywhere in the script.
You can access the variable with the either `$VARIABLE_NAME` or `${VARIABLE_NAME}`.
Now, let's update our script to include a variable:

![Using Bash Variables](/assets/imgs/bash-variables.png)

Take note of the quotes in the script, I purposefully put double `"` instead of single `'` because in bash, stuff instead double quotes `"` will be automatically interpretted as with any variables/argumnets you include.
In contrast, single quotes `'` will report back exactly what you include and will not interpret any variables inside them.
Here, is the output of the updated script:

![Bash Variables Outputs](/assets/imgs/bash-variables-output.png)

Look at the output.
It replaced `$NAME` with the actual text we used wrote.
Next, you will look at a few other ways you can make variables.


### Arguments

We have seen several previous commands that have arguments, well now its time to add them to our own script!
All arguments appended to the end of a command can be accessed with`$NUMBER`, where the number corresponds to the order they were entered into the command-line.
So, the `$1` is the first argument `$2` is the second and so on.
Let's make this clear with an example.
Edit your script to look like this:

![Script Arguments](/assets/imgs/arguments.png)

Running the updated file will give you this output:

![My first script with Arguments](/assets/imgs/args-script-output.png)

As you can see, the integer `1` was the first argument passed and was replaced anywhere I had `$1`.
Similarly, the word `TWO` was the second argument passed was replaced anywhere the script had `$2`.

Some notable other default arguments:
- `$0` will give you the the path and filename for the script that is running
- `$@` will list out all the arguments included from the command-line

Arguments are a way to allow users to alter your functions without needing to edit the file itself.
For more information of bash arguments and adding options to scripts see this [post][bash-options].

### Reading User inputs

Allowing for input arguments are useful, but they require the user to know in advance what needs to go where and in what order.
Alternatively, you could use the `read` command to read the input from the user.
Let's take a look with another example.

I have updated the script to look like this now:

![Read User Inputs](/assets/imgs/user-input-script.png)
You can append the following lines to your script:

```bash
read -p "Hello, what is your First Name:" NAME
echo "Good Morning $NAME"
```

The new `read` line uses the `-p` option to **P**rompt the user the with following text and stores whatever they type in a variable called `NAME` (more of [variables][] in the next post).
Then, on the final line, I print out Good Morning and the name that was entered in previously.

As you can imagine this is incredibly powerful because you have have your scripts perform slightly different actions depending on how the user responds.

Here is a challenge, see if you can adjust the script to use the correct greeting depending on the time of day. This is a bit challenging giving what you know to this point, but definitely worth a shot.
If you are struggling to much, the [Control the Flow][flow-control] post will help out.

## Printing Output (`echo`)

As you probably could have told by now the `echo` command prints things to the console as output.
I have talked about the `echo` command a lot, but wanted to have a single place where you can access all the information I talked about.
And here it is.
If you have been following along with this tutorial series you dont need to spend much time here, it just summarizes everything you have learned about the `echo` command.

`echo` can be used to print text with `echo TEXT`.
It can also display variables with `echo $VARNAME`.
You can even combine text and variables automatically so long as you surround them in double quotes `"` like this `echo "Hello $NAME"`.
Using single quotes `'` will print exactly whats inside regardless of it is a variable or not.
Finally, the `echo` command can also be used to make files with text or append text to an existing file.
To append text make sure you have two greator than symbols `>>` (e.g., `echo "Append this text" >> file_name`).
If you want to replace the text just use one `>` like this `echo "This text will replace all other text" > file_name`.
And of course, you can combine these principles, so you could include text to a file based on a variable: `echo "Add this var: $VARIABLE" >> file_name`.

## Extra Practice

Its really important that I harping on this point.
The only way you will improve is by actually doing attempting things.
I am giving some examples, but even better would be for you to adapt them to your needs or, better yet, come up with a project on your own.
You very likely, at this point still feel like you don't know enough to start, but that is **NOT** true.
You have learned a lot to this point, so make sure you try things out.
If you get stuck that is ok, you can always search for additional things or check out the next few points to gain more skills.

For this example, I want you to make a script to set up a new project.
The script should take in either an input argumnet and/or read in user input to create a standard folder structure for a new project.
Below you will see a sample one, but feel free to adjust it to your needs.
For extra practice, try to have the main directories name be based on a user input or argument and include a some text in the `README.md` file.
If you havent worked with `md` files also know as markdown files, check out my previous post on [them][markdown].

Try to make a new folder called `git_repos` somewhere on your computer and either move or copy a file into.
Then make `README.md` file (for advanced users try `nano` or `vim` to edit it and say something).

Inside the newly created folder you should you should have a the following structure:

```shell
my_first_bash_script/
  |-- analyses/
      |-- plots/
  |-- expriment/
      |-- data/
  |-- lit_review/
  |-- supporting_docs/
      |-- scales/
      |-- irb_docs/
  |-- DEVELOPEMENT_DECISIONS.md
  |-- README.md
```

Feel free to mess around with this structure a bit to suit your own needs, but having some basic structure for all projects is very important.
I highly highly reccommend two separate `.md` files.
The `README` is for anyone first coming to the project on how/why to run this code and what is found where (this should be updated as you continue developing the project).

In contrast the `DEVELOPMENT` file is a place where you should write down every decision you made for the project.
Why did you use this library instead of that one.
Why did you did you select these particular values etc.
I personally also leave a ton of links to stackexchange/stackoverflow for how I came up with code or to justify certain things to myself.


[permissions]: https://linuxcommand.org/lc3_lts0090.php "Permissions in Bash"
[bash-options]: https://www.redhat.com/sysadmin/arguments-options-bash-scripts "Bash Arguments and Options"
[path]: /future_links
[variables]: /future_links
[flow-control]: /future_links
[markdown]: {% post_url 2022-10-03-markdown %}
